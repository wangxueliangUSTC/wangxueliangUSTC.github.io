---
layout: article
title: Python中负数的表示以及位运算
aside:
  toc: true
mathjax: true
mathjax_autoNumber: true
tags: Python
---

<!--more-->

## 概念

### 1. 原码

原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制:

```
[+1] = 0000 0001
[-1] = 1000 0001
```

第一位是符号位。 因为第一位是符号位, 所以8位二进制数的取值范围就是:

```
[1111 1111, 0111 1111]
```

即

```
[-127, 127]
```

### 2. 反码

正数的反码是其本身

负数的反码是在其原码的基础上, 符号位不变，其余各个位取反

```
[+1] = 0000 0001 = 0000 0001
[-1] = 1000 0001 = 1111 1110
```

### 3. 补码

正数的补码就是其本身

负数的补码是在其原码的基础上, **符号位不变**, 其余各位取反, 最后+1. (即在反码的基础上+1)

```
[+1] = [0000 0001]原 = [0000 0001]反 = [0000 0001]补

[-1] = [1000 0001]原 = [1111 1110]反 = [1111 1111]补
```



## 为何要使用原码、反码和补码

首先, 因为人脑可以知道第一位是符号位, 在计算的时候我们会根据符号位, 选择对真值区域的加减. (真值的概念在本文最开头). 但是对于计算机, 加减乘数已经是最基础的运算, 要设计的尽量简单. 计算机辨别”符号位”显然会让计算机的基础电路设计变得十分复杂! 于是人们想出了将符号位也参与运算的方法. 我们知道, 根据运算法则减去一个正数等于加上一个负数, 即: 1-1 = 1 + (-1) = 0 , 所以机器可以只有加法而没有减法, 这样计算机运算的设计就更简单了。

于是人们开始探索 将符号位参与运算, 并且只保留加法的方法. 首先来看原码:

计算十进制的表达式: 1-1=0：

```
1 - 1 = 1 + (-1) = [00000001]原 + [10000001]原 = [10000010]原 = -2
```

如果用原码表示, 让符号位也参与计算, 显然对于减法来说, 结果是不正确的.这也就是为何计算机内部不使用原码表示一个数.

为了解决原码做减法的问题, 出现了反码:

计算十进制的表达式： 1-1=0

```
1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原= [0000 0001]反 + [1111 1110]反 = [1111 1111]反 = [1000 0000]原 = -0
```

发现用反码计算减法, 结果的真值部分是正确的. 而唯一的问题其实就出现在”0”这个特殊的数值上. 虽然人们理解上+0和-0是一样的, 但是0带符号是没有任何意义的. 而且会有[0000 0000]原 和[1000 0000]原 两个编码表示0。

于是补码的出现, 解决了0的符号以及两个编码的问题：

```
1-1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原 = [0000 0001]补 + [1111 1111]补 = [0000 0000]补=[0000 0000]原
```

这样0用[0000 0000]表示，而以前出现问题的-0则不存在了。而且可以用 [1000 0000] 表示-128：

```
(-1) + (-127) = [1000 0001]原 + [1111 1111]原 = [1111 1111]补 + [1000 0001]补 = [1000 0000]补
```

-1-127的结果应该是-128，在用补码运算的结果中，[1000 0000]补 就是-128。但是注意因为实际上是使用以前的-0的补码来表示-128, 所以-128并没有原码和反码表示。(对-128的补码表示 [1000 0000]补 算出来的原码是[0000 0000]原，这是不正确的)

使用补码，不仅仅修复了0的符号以及存在两个编码的问题，而且还能够多表示一个最低数。这就是为什么8位二进制，使用原码或反码表示的范围为[-127, +127], 而使用补码表示的范围为[-128, 127].



而且实际上并不是从10000001到11111111依次表示-1到-127，而是刚好相反的，从10000001到11111111依次表示-127到-1

用补码表示负数时：负数X用$2^n$ - $\|X\|$来表示，其中n为机器的字长

当n=8时，[-1]补 = $2^8$ - 1 = 11111111, [-127]补 = $2^8$ - 127 = 100000001

[-0]补 = $2^8$=00000000 在补码表示法中只有一种表示，即00000000。

## Python中的位运算



| 运算符 | 描述                                                         |
| ------ | ------------------------------------------------------------ |
| &      | 按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0 |
| \|     | 按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。 |
| ^      | 按位异或运算符：当两对应的二进位相异时，结果为1              |
| ~      | 按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1 。**~x** 类似于 **-x-1** |
| >>     | 右移动运算符：把">>"左边的运算数的各二进位全部右移若干位，**>>** 右边的数字指定了移动的位数 |
| <<     | 左移动运算符：运算数的各二进位全部左移若干位，由 **<<** 右边的数字指定了移动的位数，高位丢弃，低位补0。 |

> ###### PS：数字在计算机中是以**补码**保存的，所以用**Python**位运算作用在**补码**上，每一位都参与运算：

#### Python位运算举例

```python
>>> ~7 # 解释：7的补码是00000111 对补码取反得到11111000 该补码对应的整数为-8
-8
>>> ~-7 # 解释：-7的补码是11111001 对补码取反得到00000110 该补码对应的整数为6
6
>>> 6 & 5 
4
>>> 5 & 4
4
>>> 7 << 2
28
>>> 28 << 2
112
>>> a = -7&0xffffffff
4294967289
```



### [面试题15. 二进制中1的个数](https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/)

#### 题目

请实现一个函数，输入一个整数，输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。（负数在python中是以补码形式存在的，也就直接计算补码中有多少1）

#### 题解

方法一：

```python
class Solution:
    def hammingWeight(self, n: int) -> int:
        res = 0
        while n:
            res += n & 1
            n >>= 1 ###位运算是对所有位进行的运算，包括符号位###
        return res
```

方法二：

```python
class Solution:
    def hammingWeight(self, n: int) -> int:
        res = 0
        while n:
            res += 1
            n &= n - 1
        return res
```

方法三：

```python
class Solution:
    def NumberOf1(self, n):
        
        return bin(n & 0xffffffff).count('1')
```

注意：

1. 在Python中，进制转换的函数为：`bin()`（转换为二进制），`oct()`（转换为八进制），`hex()`（转换为十六进制），`int()`（转换为十进制）。各个进制的表示开头为：`0b`（二进制），`0o`（八进制），`0x`（十六进制）。
2. 在计算机中，所有的数字都是使用补码存储起来的。由于Python没有位数这个概念，所以得到二进制表示需要多一点操作，即将位数限制在32位，通过和一个32位的全1数字按位与运算即可。对于正数来说，上面的按位与操作可以不做，因为正数的符号位为0，补码即原码，所以前面的数字全为0，按位与没有意义。**但对于负数来说，直接`bin(-3)`是不能得到其补码的，而是得到了3的原码前面加上了负号，即`-0b11`。则通过和一个32位的全1数字按位与运算可得到其补码（按位与运算把符号位的1视为了数字）。**



### [面试题65. 不用加减乘除做加法](https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/)

#### 题目：

写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。

#### 题解：

本题是想要通过位运算来实现加法。

设两数字的二进制形式 *a*,*b* ，其求和 *s*=*a*+*b* ，*a*(*i*) 代表 *a* 的二进制第 *i* 位，则分为以下四种情况：

| a(i) | b(i) | 无进位和n(i) | 进位c(i+1) |
| ---- | ---- | ------------ | ---------- |
| 0    | 0    | 0            | 0          |
| 0    | 1    | 1            | 0          |
| 1    | 0    | 1            | 0          |
| 1    | 1    | 0            | 1          |

我们发现**无进位和** 与 **异或运算** 规律相同，**进位** 和 **与运算** 规律相同（并需左移一位）。

即可将 s*=*a*+*b* 转化为：

*s*=*a*+*b*⇒*s*=*n*+*c*

```python
class Solution:
    def add(self, a: int, b: int) -> int:
        x = 0xffffffff
        a, b = a & x, b & x
        while b != 0:
            a, b = (a ^ b), (a & b) << 1 & x
        return a if a <= 0x7fffffff else ~(a ^ x)
```

#### 注意：

> ###### 由于 Python 的数字存储特点，需要做一些特殊处理，以下详细介绍。

1. Python没有**变量位数**的概念。
2. **获取负数的补码：**需要将数字与十六进制数 `0xffffffff` 相与。可理解为舍去此数字 32 位以上的数字，从无限长度变为一个 32 位整数。
3. **返回前数字还原**：若补码 a 为负数（ 0x7fffffff 是最大的正数的补码 ），需执行 ~(a ^ x) 操作，将补码还原至 Python 的存储格式。 a ^ x 运算将 1 至 32 位按位取反； ~ 运算是将整个数字取反；因此， ~(a ^ x) 是将 32 位以上的位取反，即由 0变为 1, 1至 32位不变

以上内容参考自

1. [计算机为什么使用补码？（讲的很详细）](https://blog.csdn.net/sd631032049/article/details/72781138)

2. [由Python位运算到原码反码补码](https://blog.csdn.net/shengchaohua163/article/details/79302058)

3. [面试题65. 不用加减乘除做加法（位运算，清晰图解）](https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/solution/mian-shi-ti-65-bu-yong-jia-jian-cheng-chu-zuo-ji-7/)

